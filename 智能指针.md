## 智能指针

### shared_ptr

下面是一个简单智能指针的demo。智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。智能指针就是模拟指针动作的类。所有的智能指针都会重载 -> 和 * 操作符。智能指针还有许多其他功能，比较有用的是自动销毁。这主要是利用栈对象的有限作用域以及临时对象（有限作用域实现）析构函数释放内存。

注意出现好互相引用对方的内容，出现环路，导致资源无法释放的情况发生：

eg：

```c++
class B;
class A
{
public:
　　shared_ptr<B>
 m_b;
};
 
class B
{
public:
　　shared_ptr<A>
 m_a;
};
 
int main()
{
　　while (true)
　　{
　　　　shared_ptr<A>
 a(new A);
//new出来的A的引用计数此时为1
　　　　shared_ptr<B>
 b(new B);
//new出来的B的引用计数此时为1
　　　　a->m_b
 = b; //B的引用计数增加为2
　　　　b->m_a
 = a; //A的引用计数增加为2
　　}
 
　　//b先出作用域，B的引用计数减少为1，不为0，所以堆上的B空间没有被释放，且B持有的A也没有机会被析构，A的引用计数也完全没减少
 
　　//a后出作用域，同理A的引用计数减少为1，不为0，所以堆上A的空间也没有被释放
 
}
```


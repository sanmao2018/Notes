# 一些概念

[TOC]



####单例问题

单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例

实现办法：可以将构造函数设为private，然后设置一个公有静态方法连 创建实例，当然这个实例也是一个类成员变量，以保证实例仅有一个。

```java
public class SingletonClass{
    private static SingletonClass instance=null;
    public static　synchronized　SingletonClass getInstance(){
        if(instance==null){
               instance=new SingletonClass();
        }
        return instance;
    }
    private SingletonClass(){
    }
}
```

其中的synchronized相当于是一个排他锁，保证在多线程情况下的唯一性。

#### sokect

网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。

建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。

##### 函数原型：

int socket(int **domain**, int **\*type***, int **\*protocol***);

参数说明：**　　**

**domain**：协议域，又称协议族（family）。常用的协议族有AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域Socket）、AF_ROUTE等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。

**\*type***：指定Socket类型。常用的socket类型有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等。流式Socket（SOCK_STREAM）是一种面向连接的Socket，针对于面向连接的TCP服务应用。数据报式Socket（SOCK_DGRAM）是一种无连接的Socket，对应于无连接的[UDP](https://baike.baidu.com/item/UDP)服务应用。

**\*protocol***：指定协议。常用协议有IPPROTO_TCP、IPPROTO_UDP、IPPROTO_STCP、IPPROTO_TIPC等，分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。

注意：1.type和protocol不可以随意组合，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当第三个参数为0时，会自动选择第二个参数类型对应的默认协议。

2.WindowsSocket下**\*protocol***参数中不存在IPPROTO_STCP**\*　　***

返回值：

如果调用成功就返回新创建的[套接字](https://baike.baidu.com/item/%E5%A5%97%E6%8E%A5%E5%AD%97)的描述符，如果失败就返回INVALID_SOCKET（Linux下失败返回-1）。套接字描述符是一个整数类型的值。每个进程的进程空间里都有一个套接字描述符表，该表中存放着套接字描述符和套接字数据结构的对应关系。该表中有一个字段存放新创建的套接字的描述符，另一个字段存放套接字数据结构的地址，因此根据套接字描述符就可以找到其对应的套接字数据结构。每个进程在自己的进程空间里都有一个套接字描述符表但是套接字数据结构都是在操作系统的[内核](https://baike.baidu.com/item/%E5%86%85%E6%A0%B8)缓冲里。

##### 绑定

int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);

服务端直接绑定自己的地址和端口号，客户端可以不写，内核会分配给它一个临时的端口

##### 连接

int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);

TCP客户端通过connect与服务端进行连接

##### listen

int listen(int sockfd, int backlog)

listen函数使用主动连接套接口变为被连接套接口，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程。在TCP服务器编程中listen函数把进程变为一个服务器，并指定相应的套接字变为被动连接。

listen函数在一般在调用bind之后-调用accept之前调用，它的函数原型是：

##### accept

accept()是在一个套接口接受的一个连接。

#### 多线程锁

1. 互斥锁

   互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说为例避免多个线程在某一时刻同时操作一个共享资源。例如线程池中的有多个空闲线程和一个任务队列。任何是一个线程都要使用互斥锁互斥访问任务队列，以避免多个线程同时访问任务队列以发生错乱。

   在某一时刻只有一个线程可以获取互斥锁，在是释放互斥锁之前，其他线程都不能获取该互斥锁。如果其他线程要获取这个互斥锁，那么线程只能以阻塞的方式进行等待。

2. 条件锁

   条件锁就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量是该线程处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。

3. 自旋锁

   前面的两种锁是比较常见的锁，也比较容易理解。下面通过比较互斥锁和自旋锁原理的不同，这对于真正理解自旋锁有很大帮助。

   假设我们有一个两个处理器core1和core2计算机，现在在这台计算机上运行的程序中有两个线程：T1和T2分别在处理器core1和core2上运行，两个线程之间共享着一个资源。

   首先我们说明互斥锁的工作原理，互斥锁是是一种sleep-waiting的锁。假设线程T1获取互斥锁并且正在core1上运行时，此时线程T2也想要获取互斥锁（pthread_mutex_lock），但是由于T1正在使用互斥锁使得T2被阻塞。当T2处于阻塞状态时，T2被放入到等待队列中去，处理器core2会去处理其他任务而不必一直等待（忙等）。也就是说处理器不会因为线程阻塞而空闲着，它去处理其他事务去了。

   而自旋锁就不同了，自旋锁是一种busy-waiting的锁。也就是说，如果T1正在使用自旋锁，而T2也去申请这个自旋锁，此时T2肯定得不到这个自旋锁。与互斥锁相反的是，此时运行T2的处理器core2会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。

   从“自旋锁”的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一致占用CPU请求这个自旋锁使得CPU不能去做其他的事情，直到获取这个锁为止，这就是“自旋”的含义。

   当发生阻塞时，互斥锁可以让CPU去处理其他的任务；而自旋锁让CPU一直不断循环请求获取这个锁。通过两个含义的对比可以我们知道“自旋锁”是比较耗费CPU的。

4. 读写锁

   说到读写锁我们可以借助于“读者-写者”问题进行理解。首先我们简单说下“读者-写者”问题。

   计算机中某些数据被多个进程共享，对数据库的操作有两种：一种是读操作，就是从数据库中读取数据不会修改数据库中内容；另一种就是写操作，写操作会修改数据库中存放的数据。因此可以得到我们允许在数据库上同时执行多个“读”操作，但是某一时刻只能在数据库上有一个“写”操作来更新数据。这就是一个简单的读者-写者模型。

#### linux下的僵尸进程

在linux系统中，当用ps命令观察进程的执行状态时，经常看到某些进程的状态栏为defunct，这就是所谓的“僵尸”进程。“僵尸”进程是一个早已死亡的进程，但在进程表（processs table）中仍占了一个位置（slot）。由于进程表的容量是有限的，所以，defunct进程不仅占用系统的内存资源，影响系统的性能，而且如果其数目太多，还会导致系统瘫痪。

**一、僵尸进程的产生原因**

我们知道，每个进程在进程表里都有一个进入点（entry），核心程序执行该进程时使用到的一切信息都存储在进入点。当用ps命令察看系统中的进程信息时，看到的就是进程表中的相关数据。

所以，当一个父进程以fork()系统调用建立一个新的子进程后，核心进程就会在进程表中给这个子进程分配一个进入点，然后将相关信息存储在该进入点所对应的进程表内。这些信息中有一项是其父进程的识别码。

而当这个子进程结束的时候（比如调用exit命令结束），其实他并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用exit的作用是使进程退出，但是也仅仅限于一个正常的进程变成了一个僵尸进程，并不能完全将其销毁）。此时原来进程表中的数据会被该进程的退出码（exit code）、执行时所用的CPU时间等数据所取代，这些数据会一直保留到系统将它传递给它的父进程为止。由此可见，defunct进程的出现时间是在子进程终止后，但是父进程尚未读取这些数据之前。

此时，该僵尸子进程已经放弃了几乎所有的内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态信息供其他进程收集，除此之外，僵尸进程不再占有任何存储空间。他需要他的父进程来为他收尸，如果他的父进程没有安装SIGCHLD信号处理函数调用wait 或 waitpid() 等待子进程结束，也没有显式忽略该信号，那么它就一直保持僵尸状态，如果这时候父进程结束了，那么init进程会自动接手这个子进程，为他收尸，他还是能被清除掉的。但是如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是系统中为什么有时候会有很多的僵尸进程。

**二、如何杀死僵尸进程**

如上可知，僵尸进程一旦出现之后，很难自己消亡，会一直存在下去，直至系统重启。虽然僵尸进程几乎不占系统资源，但是，这样下去，数量太多了之后，终究会给系统带来其他的影响。因此，如果一旦见到僵尸进程，我们就要将其杀掉。如何杀掉僵尸进程呢？

有同学可能会说，很简单嘛，直接使用kill命令就好啊。或者，实在不行，加一个-9的后缀（kill -9），肯定杀掉！

请注意：defunct状态下的僵尸进程是不能直接使用kill -9命令杀掉的，否则就不叫僵尸进程了。那么，该如何杀呢？

**方法有二：**

1. 重启服务器电脑，这个是最简单，最易用的方法，但是如果你服务器电脑上运行有其他的程序，那么这个方法，代价很大。所以，尽量使用下面一种方法。
2. 找到该defunct僵尸进程的父进程，将该进程的父进程杀掉，则此defunct进程将自动消失。

问题又来了，如何找到defunct僵尸进程的父进程呢？

很简单，一句命令就够了：ps -ef | grep defunct_process_pid。



**三、如何预防僵尸进程**

以上介绍的只是在发现了僵尸进程之后，如何去杀死它。那么，有同学可能会说了，这个是治标不治本的。真正的办法是，不让它产生，问题才能彻底解决。OK，那我们就来介绍一下，如何预防僵尸进程的产生。

- 在父进程创建子进程之前，就向系统申明自己并不会对这个子进程的exit动作进行任何关注行为，这样的话，子进程一旦退出后，系统就不会去等待父进程的操作，而是直接将该子进程的资源回收掉，也就不会出现僵尸进程了。具体的办法就是，在父进程的初始化函数中，调用这个函数：signal(SIGCHLD,SIG_IGN)；
- 如果上述语句没来得及调用，也有另外一个办法。那就是在创建完子进程后，用waitpid等待子进程返回，也能达到上述效果；
- 如果上述两个办法都不愿意采用，那还有一招：在父进程创建子进程的时候，连续调用两次fork()，而且使紧跟的子进程直接退出，使其孙子进程成为孤儿进程，从而init进程将代替父进程来接手，负责清除这个孤儿进程。于是，父进程就无需进行任何的清理行为，系统会自动处理；



#### linux 下的孤儿进程

 　孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

​     **孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上**，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。**因此孤儿进程并不会有什么危害。（如果孤儿进程是持续运行危害就不小了吧）

#### windows下的进程管理

Windows没有僵尸进程这个概念。进程之间相互独立，不需要父进程清理。当然，如果有必要的话，作者可以自行编写进程之间的同步代码。

windows下进程的父子关系很弱，不需要父进程回收子进程信息

#### C++设计模式总结

#####设计模式简介

设计模式为开发人员提供一种使用专家设计经验的有效途径。设计模式中运用了面向对象编程语言的重要特征：封装、继承、多态等。

常见的设计模式主要有：工厂模式、策略模式、适配器模式、单例模式、原型模式、模板方法模式、建造者模式、外观模式、组合模式、代理模式、享元模式、桥接模式、修饰模式、备忘录模式、中介者模式、职责链模式、观察者模式、状态模式。

工厂模式属于创建型模式，分为以下三类：简单工厂模式、工厂方法模式、抽象工厂模式。

简单工厂模式：主要特点是需要在共产类中做判断，从而创建相应的产品。当增加新产品时，需要修改工厂类。

![img](http://i.imgur.com/7lrlwPd.jpg)

缺点：需要增加新的类型时，需要修改工厂类。违反了开放封闭原则：软件实体（类、模块、函数）可以扩展，但是不可修改。

工厂方法模式：指定义一个用于创建对象的接口，让子类决定实例化哪一个类。

![img](http://i.imgur.com/V4mbLrc.jpg)

缺点：当增加一种新产品，就需要创建一个对象的工厂。当新产品很多时，就会有很多的类定义。

抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

![img](http://i.imgur.com/haRMRLi.jpg)





#####策略模式

策略模式：指定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立与使用它的客户而变化。即算法所完成的功能和对外接口一样，只是各自实现细节上存在差异。策略模式封装算法，效果比较好。

举例：Cache替换算法。当发生Cache缺失时，Cache控制器必须选择Cache中的一行，并用欲获得的数据来替换。采用的策略就是Cache替换算法。

![img](http://i.imgur.com/nj5VsQC.jpg)

ReplaceAlgorithm是一个抽象类，定义了算法的接口，有三个雷继承自这个抽象类，即具体算法实现。故维护一个ReplaceAlgorithm对象。

Cache定义及实现，直接影响客户的使用方式。关键在于如何指定替换算法。

1）直接通过参数指定，传入一个特征算法的指针。缺点：客户需要知道算法具体定义，从而暴露太多算法细节。

2）直接通过参数指定，不传入指针，而是标签。通过标签，调用对应算法。与一相比，用起来方便。其实质是简单工厂模式与策略模式结合。

3）利用模板实现。通过模板指定实参。还实用参数，不过不是构造函数参数。策略模式中，参数传递难以避免，客户必须指定某种算法。

##### 适配器模式

适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。它包括类适配器和对象适配器。

举例：STL就用到了适配器模式。STL实现一种数据结构，双端队列，支持前后两段的插入与删除。STL实现栈和队列时，没有从头开始定义它们，而是直接使用双端队列实现。双端队列扮演了适配器角色。队列用到了它的后端插入，前端删除。栈则用到它的后端删除，后端插入。栈和队列都是一种顺序容器，存在两种操作：压入和弹出。

![img](http://i.imgur.com/IXy87vq.jpg)

##### 单例模式

单例模式：实现较简单。其构造函数是私有的，故无法通过构造函数实例化，唯一的方法是通过调用静态函数GetInstance。

![img](http://i.imgur.com/k7ab9S0.jpg)

原型模式实现的关键是实现clone函数，对C++而言，其实质是拷贝构造函数，即实现深拷贝。

##### 原型模式

原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。拷贝是原型模式的精髓。

![img](http://i.imgur.com/cmfthfr.jpg)

原型模式实现的关键是实现clone函数，对C++而言，其实质是拷贝构造函数，即实现深拷贝。

##### 模板方法模式

模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。即在父类中定义操作算法骨架，具体由子类实现。

![img](http://i.imgur.com/I6p1fdd.jpg)

其中在FillResume()中定义操作的骨架，然后调用子类实现函数。

##### 建造者模式

建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构造过程可以创建不同的表示。

![img](http://i.imgur.com/lxaT89c.jpg)

对用户来说，只需知道导向者即可，通过导向者，客户能够构造复杂的对象，而不需要知道具体的构造过程。

##### 外观者模式

外观着模式：使用很多的一种模式，特别是当一个系统很复杂时，系统提供给客户的是一个简单的对外接口，而把里面复杂的结构都封装起来。客户只需使用这些简单接口就能使用这个系统，而不需关注内部复杂的结构。另一种定义：为子系统中的一组接口提供一个一致的节点，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

举例：编译系统就使用外观着。原因是编译系统复杂，实际四个步骤为词法分析、语法分析、中间代码生成、机器码生成，这四个步骤实现都很复杂，故可定义一个高层接口，如Compiler类，然后定义一个run函数，run函数内部具体实现，对用户透明，即客户不需知道。

![img](http://i.imgur.com/BHNMMPm.jpg)

外观着模式特点：1）它对客户屏蔽子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便；2）实现了子系统与客户之间松耦合关系，而子系统内部的功能组件往往是紧耦合的；3）如果应用需要，它并不限制它们使用子系统类。

##### 组合模式

组合模式：将对象组合成树形结构以表示“整体——部分”的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性。其关键是树形结构。

![img](http://i.imgur.com/lrkXesu.jpg)

##### 代理模式（这个思想在之后可能会用上）

代理模式：为其他对象提供一种代理以控制对这个对象的访问。四种常用的情况：1）远程代理；2）虚代理；3）保护代理；4）智能引用。

举例：考虑一个可以在文档中嵌入图形对象的文档编辑器。有些图形对象的创建开销很大。但是打开文档必须很迅速，故在打开文档时应避免一次性创建所有开销很大的对象。在此，运用代理模式，在打开文档时，并不打开图像对象，而是打开图形对象的代理以替代真实的图形。待到真正需要打开图形时，扔由代理负责打开。

![img](http://i.imgur.com/pqGcwN6.jpg)

#####享元模式

享元模式：运用共享技术有效地支持大量细粒度的对象。

举例：在围棋中，棋子就是大量细粒度的对象。其属性有内在的，如颜色、形状等，也有外在的，如棋盘位置等。内在的属性可以共享，区分在外在属性。故设计时，只需要定义两个棋子的对象，一颗黑棋和一颗白棋，这两个对象含棋子的内在属性，棋子外在属性，即在棋盘上的位置可以读取出来，存放在单独的容器中。容器中只需存放位置，可以减少对空间的需求。

##### 桥接模式

桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立地变化。

举例：考虑装操作系统，有多种配置的计算机，同样也有多款操作系统。如何运用桥接模式呢？可以将操作系统和计算机分别抽象出来，让它们各自发展，减少它们的耦合度。当然了，两者之间有标准的接口。这样的设计，不论是对于计算机，还是操作系统都是非常有利的。

![img](http://i.imgur.com/nSlQUJm.jpg)

##### 装饰模式

装饰模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。有时我们希望给某个对象而不是整个类添加一些功能。

举例：对有一个手机，允许为其添加特性，如增加挂件、屏幕贴膜等。一个灵活的设计方式是，将手机嵌入到另一个对象中，由这个对象完成特性的添加，称此嵌入对象为修饰。这个装饰与其它所装饰的组件接口一致。故它对使用该组件的用户透明。

![img](http://i.imgur.com/nwYUFEI.jpg)

装饰模式提供了更加灵活的面向对象添加职责的方式。可以用添加和分离的方法，用装饰在运行时刻增加和删除职责。装饰模式提供了一种“即用即付”的方法来添加职责。它并不视图在一个复杂的可定制的类中支持所有可预见的特征，相反，你可以定义一个简单的类，并且用装饰类给它逐渐地添加功能。可以从简单的部件组合出复杂的功能。

#####备忘录模式

备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

举例：玩游戏时，都会保存进度，所保存的进度以文件的形式存在。下次就可以继续玩，而不是从头开始。此处的进度其实就是游戏的内部状态，文件则是游戏之外的保存状态。下次可从文件中读取保存的进度，从而恢复到原来的状态。这就是备忘录模式。

![img](http://i.imgur.com/P7uDCaw.jpg)

Memento类定义了内部的状态，而Caretake类是一个保存进度的管理者，GameRole类是游戏角色类。由上图可得GameRole的对象依赖于Memento对象，而与Caretake对象无关。

##### 中介者模式

中介者模式：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。在软件中，就是多个对象之间需要通信，如果没有中介，对象就需要知道其他对象，最坏情况下，可能需要知道所有其他的对象，而有了中介对象就方便多了，对象只需要与中介对象通信，而不用知道其他的对象。

![img](http://i.imgur.com/PZN46oA.jpg)

##### 职责链模式

职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

![img](http://i.imgur.com/HQeK3JN.jpg)

##### 观察者模式

观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。它还有两个别名，依赖（Dependents），发布-订阅（Publish-Subsrcibe）。

举例：博客订阅例子。当博主发表新文章的时候，即博主状态发生了改变，那些订阅的读者就会收到通知，然后进行相应的动作，如去看文章，或者收藏等。博主与读者之间存在一种一对多的依赖关系。

![img](http://i.imgur.com/xqpvlpB.jpg)

其中，博客类中有一个观察者链表（即订阅者），当博客的状态发生变化时，通过Notify成员函数通知所有的观察者，告诉他们博客的状态更新了。而观察者通过Update成员函数获取博客的状态信息。博客类主要完成观察者的添加、移除、通知等操作，设置和获得状态仅仅是一个默认实现。

#####状态模式

状态模式：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。它的两种使用情况：1）一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为；2）一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。

举例：以战争为例，假设一场战争需经历四个阶段：前期、中期、后期、结束。当战争处于不同的阶段，战争的行为是不一样的，即战争的行为取决于所处的阶段，而且随时间的推进是动态变化的。

![img](http://i.imgur.com/k8kUj9z.jpg)

##### 迭代器模式

迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

迭代器模式属于行为型模式。

介绍

意图：**提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。

主要解决：**不同的方式来遍历整个整合对象。

何时使用：**遍历一个聚合对象。

如何解决：**把在元素之间游走的责任交给迭代器，而不是聚合对象。

关键代码：**定义接口：hasNext, next。

应用实例：**JAVA 中的 iterator。

优点：** 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。

缺点：**由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。

使用场景：** 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。

注意事项：**迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。

实现

我们将创建一个叙述导航方法的 *Iterator* 接口和一个返回迭代器的 *Container* 接口。实现了 *Container* 接口的实体类将负责实现 *Iterator* 接口。

*IteratorPatternDemo*，我们的演示类使用实体类 *NamesRepository* 来打印 *NamesRepository* 中存储为集合的 *Names*。

![迭代器模式的 UML 图](http://www.runoob.com/wp-content/uploads/2014/08/iterator_pattern_uml_diagram.jpg)

```java
public interface Iterator {
   public boolean hasNext();
   public Object next();
}

public interface Container {
   public Iterator getIterator();
}


public class NameRepository implements Container {
   public String names[] = {"Robert" , "John" ,"Julie" , "Lora"};

   @Override
   public Iterator getIterator() {
      return new NameIterator();
   }

   private class NameIterator implements Iterator {

      int index;

      @Override
      public boolean hasNext() {
         if(index < names.length){
            return true;
         }
         return false;
      }

      @Override
      public Object next() {
         if(this.hasNext()){
            return names[index++];
         }
         return null;
      }        
   }
}

public class IteratorPatternDemo {
    
   public static void main(String[] args) {
      NameRepository namesRepository = new NameRepository();

      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){
         String name = (String)iter.next();
         System.out.println("Name : " + name);
      }     
   }
}
```

##### 各种设计模式综合

装饰者模式：包装一个对象，以提供新的行为。

状态模式：封装了基本状态行为，并使用委托在行为之间切换。

迭代器模式：在对象的集合之中游走，而不暴露集合的实现。

外观模式：简化一群类的接口。

策略模式：封装可以互换的行为，并使用委托在行为之间切换。

代理模式：包装对象，以控制对此对象的访问。

工厂方法模式：有子类决定要创建的具体类是哪一个。

适配器模式：封装对象，并提供不同的接口。

观察者模式：让对象能够在状态改变时被通知。

模板方法模式：由子类决定如何实现一个算法中的步骤。

组合模式：客户用一致的方式处理对象集合和单个对象。

单件模式：确保有且只有一个对象被创建。

抽象工厂模式：允许客户创建对象的家族，而无需指定它们的具体类。

命令模式：封装请求成为对象。

#### isp



互联网服务供应商


# 一些概念

[TOC]



####单例问题

单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例

实现办法：可以将构造函数设为private，然后设置一个公有静态方法连 创建实例，当然这个实例也是一个类成员变量，以保证实例仅有一个。

```java
public class SingletonClass{
    private static SingletonClass instance=null;
    public static　synchronized　SingletonClass getInstance(){
        if(instance==null){
               instance=new SingletonClass();
        }
        return instance;
    }
    private SingletonClass(){
    }
}
```

其中的synchronized相当于是一个排他锁，保证在多线程情况下的唯一性。

#### sokect

网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。

建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。

##### 函数原型：

int socket(int **domain**, int **\*type***, int **\*protocol***);

参数说明：**　　**

**domain**：协议域，又称协议族（family）。常用的协议族有AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域Socket）、AF_ROUTE等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。

**\*type***：指定Socket类型。常用的socket类型有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等。流式Socket（SOCK_STREAM）是一种面向连接的Socket，针对于面向连接的TCP服务应用。数据报式Socket（SOCK_DGRAM）是一种无连接的Socket，对应于无连接的[UDP](https://baike.baidu.com/item/UDP)服务应用。

**\*protocol***：指定协议。常用协议有IPPROTO_TCP、IPPROTO_UDP、IPPROTO_STCP、IPPROTO_TIPC等，分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。

注意：1.type和protocol不可以随意组合，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当第三个参数为0时，会自动选择第二个参数类型对应的默认协议。

2.WindowsSocket下**\*protocol***参数中不存在IPPROTO_STCP**\*　　***

返回值：

如果调用成功就返回新创建的[套接字](https://baike.baidu.com/item/%E5%A5%97%E6%8E%A5%E5%AD%97)的描述符，如果失败就返回INVALID_SOCKET（Linux下失败返回-1）。套接字描述符是一个整数类型的值。每个进程的进程空间里都有一个套接字描述符表，该表中存放着套接字描述符和套接字数据结构的对应关系。该表中有一个字段存放新创建的套接字的描述符，另一个字段存放套接字数据结构的地址，因此根据套接字描述符就可以找到其对应的套接字数据结构。每个进程在自己的进程空间里都有一个套接字描述符表但是套接字数据结构都是在操作系统的[内核](https://baike.baidu.com/item/%E5%86%85%E6%A0%B8)缓冲里。

##### 绑定

int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);

服务端直接绑定自己的地址和端口号，客户端可以不写，内核会分配给它一个临时的端口

##### 连接

int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);

TCP客户端通过connect与服务端进行连接

##### listen

int listen(int sockfd, int backlog)

listen函数使用主动连接套接口变为被连接套接口，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程。在TCP服务器编程中listen函数把进程变为一个服务器，并指定相应的套接字变为被动连接。

listen函数在一般在调用bind之后-调用accept之前调用，它的函数原型是：

##### accept

accept()是在一个套接口接受的一个连接。

#### 多线程锁

1. 互斥锁

   互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说为例避免多个线程在某一时刻同时操作一个共享资源。例如线程池中的有多个空闲线程和一个任务队列。任何是一个线程都要使用互斥锁互斥访问任务队列，以避免多个线程同时访问任务队列以发生错乱。

   在某一时刻只有一个线程可以获取互斥锁，在是释放互斥锁之前，其他线程都不能获取该互斥锁。如果其他线程要获取这个互斥锁，那么线程只能以阻塞的方式进行等待。

2. 条件锁

   条件锁就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量是该线程处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。

3. 自旋锁

   前面的两种锁是比较常见的锁，也比较容易理解。下面通过比较互斥锁和自旋锁原理的不同，这对于真正理解自旋锁有很大帮助。

   假设我们有一个两个处理器core1和core2计算机，现在在这台计算机上运行的程序中有两个线程：T1和T2分别在处理器core1和core2上运行，两个线程之间共享着一个资源。

   首先我们说明互斥锁的工作原理，互斥锁是是一种sleep-waiting的锁。假设线程T1获取互斥锁并且正在core1上运行时，此时线程T2也想要获取互斥锁（pthread_mutex_lock），但是由于T1正在使用互斥锁使得T2被阻塞。当T2处于阻塞状态时，T2被放入到等待队列中去，处理器core2会去处理其他任务而不必一直等待（忙等）。也就是说处理器不会因为线程阻塞而空闲着，它去处理其他事务去了。

   而自旋锁就不同了，自旋锁是一种busy-waiting的锁。也就是说，如果T1正在使用自旋锁，而T2也去申请这个自旋锁，此时T2肯定得不到这个自旋锁。与互斥锁相反的是，此时运行T2的处理器core2会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。

   从“自旋锁”的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一致占用CPU请求这个自旋锁使得CPU不能去做其他的事情，直到获取这个锁为止，这就是“自旋”的含义。

   当发生阻塞时，互斥锁可以让CPU去处理其他的任务；而自旋锁让CPU一直不断循环请求获取这个锁。通过两个含义的对比可以我们知道“自旋锁”是比较耗费CPU的。

4. 读写锁

   说到读写锁我们可以借助于“读者-写者”问题进行理解。首先我们简单说下“读者-写者”问题。

   计算机中某些数据被多个进程共享，对数据库的操作有两种：一种是读操作，就是从数据库中读取数据不会修改数据库中内容；另一种就是写操作，写操作会修改数据库中存放的数据。因此可以得到我们允许在数据库上同时执行多个“读”操作，但是某一时刻只能在数据库上有一个“写”操作来更新数据。这就是一个简单的读者-写者模型。

#### linux下的僵尸进程

在linux系统中，当用ps命令观察进程的执行状态时，经常看到某些进程的状态栏为defunct，这就是所谓的“僵尸”进程。“僵尸”进程是一个早已死亡的进程，但在进程表（processs table）中仍占了一个位置（slot）。由于进程表的容量是有限的，所以，defunct进程不仅占用系统的内存资源，影响系统的性能，而且如果其数目太多，还会导致系统瘫痪。

**一、僵尸进程的产生原因**

我们知道，每个进程在进程表里都有一个进入点（entry），核心程序执行该进程时使用到的一切信息都存储在进入点。当用ps命令察看系统中的进程信息时，看到的就是进程表中的相关数据。

所以，当一个父进程以fork()系统调用建立一个新的子进程后，核心进程就会在进程表中给这个子进程分配一个进入点，然后将相关信息存储在该进入点所对应的进程表内。这些信息中有一项是其父进程的识别码。

而当这个子进程结束的时候（比如调用exit命令结束），其实他并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用exit的作用是使进程退出，但是也仅仅限于一个正常的进程变成了一个僵尸进程，并不能完全将其销毁）。此时原来进程表中的数据会被该进程的退出码（exit code）、执行时所用的CPU时间等数据所取代，这些数据会一直保留到系统将它传递给它的父进程为止。由此可见，defunct进程的出现时间是在子进程终止后，但是父进程尚未读取这些数据之前。

此时，该僵尸子进程已经放弃了几乎所有的内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态信息供其他进程收集，除此之外，僵尸进程不再占有任何存储空间。他需要他的父进程来为他收尸，如果他的父进程没有安装SIGCHLD信号处理函数调用wait 或 waitpid() 等待子进程结束，也没有显式忽略该信号，那么它就一直保持僵尸状态，如果这时候父进程结束了，那么init进程会自动接手这个子进程，为他收尸，他还是能被清除掉的。但是如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是系统中为什么有时候会有很多的僵尸进程。

**二、如何杀死僵尸进程**

如上可知，僵尸进程一旦出现之后，很难自己消亡，会一直存在下去，直至系统重启。虽然僵尸进程几乎不占系统资源，但是，这样下去，数量太多了之后，终究会给系统带来其他的影响。因此，如果一旦见到僵尸进程，我们就要将其杀掉。如何杀掉僵尸进程呢？

有同学可能会说，很简单嘛，直接使用kill命令就好啊。或者，实在不行，加一个-9的后缀（kill -9），肯定杀掉！

请注意：defunct状态下的僵尸进程是不能直接使用kill -9命令杀掉的，否则就不叫僵尸进程了。那么，该如何杀呢？

**方法有二：**

1. 重启服务器电脑，这个是最简单，最易用的方法，但是如果你服务器电脑上运行有其他的程序，那么这个方法，代价很大。所以，尽量使用下面一种方法。
2. 找到该defunct僵尸进程的父进程，将该进程的父进程杀掉，则此defunct进程将自动消失。

问题又来了，如何找到defunct僵尸进程的父进程呢？

很简单，一句命令就够了：ps -ef | grep defunct_process_pid。



**三、如何预防僵尸进程**

以上介绍的只是在发现了僵尸进程之后，如何去杀死它。那么，有同学可能会说了，这个是治标不治本的。真正的办法是，不让它产生，问题才能彻底解决。OK，那我们就来介绍一下，如何预防僵尸进程的产生。

- 在父进程创建子进程之前，就向系统申明自己并不会对这个子进程的exit动作进行任何关注行为，这样的话，子进程一旦退出后，系统就不会去等待父进程的操作，而是直接将该子进程的资源回收掉，也就不会出现僵尸进程了。具体的办法就是，在父进程的初始化函数中，调用这个函数：signal(SIGCHLD,SIG_IGN)；
- 如果上述语句没来得及调用，也有另外一个办法。那就是在创建完子进程后，用waitpid等待子进程返回，也能达到上述效果；
- 如果上述两个办法都不愿意采用，那还有一招：在父进程创建子进程的时候，连续调用两次fork()，而且使紧跟的子进程直接退出，使其孙子进程成为孤儿进程，从而init进程将代替父进程来接手，负责清除这个孤儿进程。于是，父进程就无需进行任何的清理行为，系统会自动处理；



#### linux 下的孤儿进程

 　孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

​     **孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上**，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。**因此孤儿进程并不会有什么危害。（如果孤儿进程是持续运行危害就不小了吧）

#### windows下的进程管理

Windows没有僵尸进程这个概念。进程之间相互独立，不需要父进程清理。当然，如果有必要的话，作者可以自行编写进程之间的同步代码。

windows下进程的父子关系很弱，不需要父进程回收子进程信息

#### C++设计模式总结

#####设计模式简介

设计模式为开发人员提供一种使用专家设计经验的有效途径。设计模式中运用了面向对象编程语言的重要特征：封装、继承、多态等。

常见的设计模式主要有：工厂模式、策略模式、适配器模式、单例模式、原型模式、模板方法模式、建造者模式、外观模式、组合模式、代理模式、享元模式、桥接模式、修饰模式、备忘录模式、中介者模式、职责链模式、观察者模式、状态模式。

工厂模式属于创建型模式，分为以下三类：简单工厂模式、工厂方法模式、抽象工厂模式。

简单工厂模式：主要特点是需要在共产类中做判断，从而创建相应的产品。当增加新产品时，需要修改工厂类。

![img](http://i.imgur.com/7lrlwPd.jpg)

缺点：需要增加新的类型时，需要修改工厂类。违反了开放封闭原则：软件实体（类、模块、函数）可以扩展，但是不可修改。

工厂方法模式：指定义一个用于创建对象的接口，让子类决定实例化哪一个类。

![img](http://i.imgur.com/V4mbLrc.jpg)

缺点：当增加一种新产品，就需要创建一个对象的工厂。当新产品很多时，就会有很多的类定义。

抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

![img](http://i.imgur.com/haRMRLi.jpg)





#####策略模式

策略模式：指定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立与使用它的客户而变化。即算法所完成的功能和对外接口一样，只是各自实现细节上存在差异。策略模式封装算法，效果比较好。

举例：Cache替换算法。当发生Cache缺失时，Cache控制器必须选择Cache中的一行，并用欲获得的数据来替换。采用的策略就是Cache替换算法。

![img](http://i.imgur.com/nj5VsQC.jpg)

ReplaceAlgorithm是一个抽象类，定义了算法的接口，有三个雷继承自这个抽象类，即具体算法实现。故维护一个ReplaceAlgorithm对象。

Cache定义及实现，直接影响客户的使用方式。关键在于如何指定替换算法。

1）直接通过参数指定，传入一个特征算法的指针。缺点：客户需要知道算法具体定义，从而暴露太多算法细节。

2）直接通过参数指定，不传入指针，而是标签。通过标签，调用对应算法。与一相比，用起来方便。其实质是简单工厂模式与策略模式结合。

3）利用模板实现。通过模板指定实参。还实用参数，不过不是构造函数参数。策略模式中，参数传递难以避免，客户必须指定某种算法。

##### 适配器模式

适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。它包括类适配器和对象适配器。

举例：STL就用到了适配器模式。STL实现一种数据结构，双端队列，支持前后两段的插入与删除。STL实现栈和队列时，没有从头开始定义它们，而是直接使用双端队列实现。双端队列扮演了适配器角色。队列用到了它的后端插入，前端删除。栈则用到它的后端删除，后端插入。栈和队列都是一种顺序容器，存在两种操作：压入和弹出。

![img](http://i.imgur.com/IXy87vq.jpg)

##### 单例模式

单例模式：实现较简单。其构造函数是私有的，故无法通过构造函数实例化，唯一的方法是通过调用静态函数GetInstance。

![img](http://i.imgur.com/k7ab9S0.jpg)

原型模式实现的关键是实现clone函数，对C++而言，其实质是拷贝构造函数，即实现深拷贝。

##### 原型模式

原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。拷贝是原型模式的精髓。

![img](http://i.imgur.com/cmfthfr.jpg)

原型模式实现的关键是实现clone函数，对C++而言，其实质是拷贝构造函数，即实现深拷贝。

##### 模板方法模式

模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。即在父类中定义操作算法骨架，具体由子类实现。

![img](http://i.imgur.com/I6p1fdd.jpg)

其中在FillResume()中定义操作的骨架，然后调用子类实现函数。

##### 建造者模式

建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构造过程可以创建不同的表示。

![img](http://i.imgur.com/lxaT89c.jpg)

对用户来说，只需知道导向者即可，通过导向者，客户能够构造复杂的对象，而不需要知道具体的构造过程。

##### 外观者模式

外观着模式：使用很多的一种模式，特别是当一个系统很复杂时，系统提供给客户的是一个简单的对外接口，而把里面复杂的结构都封装起来。客户只需使用这些简单接口就能使用这个系统，而不需关注内部复杂的结构。另一种定义：为子系统中的一组接口提供一个一致的节点，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

举例：编译系统就使用外观着。原因是编译系统复杂，实际四个步骤为词法分析、语法分析、中间代码生成、机器码生成，这四个步骤实现都很复杂，故可定义一个高层接口，如Compiler类，然后定义一个run函数，run函数内部具体实现，对用户透明，即客户不需知道。

![img](http://i.imgur.com/BHNMMPm.jpg)

外观着模式特点：1）它对客户屏蔽子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便；2）实现了子系统与客户之间松耦合关系，而子系统内部的功能组件往往是紧耦合的；3）如果应用需要，它并不限制它们使用子系统类。

##### 组合模式

组合模式：将对象组合成树形结构以表示“整体——部分”的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性。其关键是树形结构。

![img](http://i.imgur.com/lrkXesu.jpg)

##### 代理模式（这个思想在之后可能会用上）

代理模式：为其他对象提供一种代理以控制对这个对象的访问。四种常用的情况：1）远程代理；2）虚代理；3）保护代理；4）智能引用。

举例：考虑一个可以在文档中嵌入图形对象的文档编辑器。有些图形对象的创建开销很大。但是打开文档必须很迅速，故在打开文档时应避免一次性创建所有开销很大的对象。在此，运用代理模式，在打开文档时，并不打开图像对象，而是打开图形对象的代理以替代真实的图形。待到真正需要打开图形时，扔由代理负责打开。

![img](http://i.imgur.com/pqGcwN6.jpg)

#####享元模式

享元模式：运用共享技术有效地支持大量细粒度的对象。

举例：在围棋中，棋子就是大量细粒度的对象。其属性有内在的，如颜色、形状等，也有外在的，如棋盘位置等。内在的属性可以共享，区分在外在属性。故设计时，只需要定义两个棋子的对象，一颗黑棋和一颗白棋，这两个对象含棋子的内在属性，棋子外在属性，即在棋盘上的位置可以读取出来，存放在单独的容器中。容器中只需存放位置，可以减少对空间的需求。

##### 桥接模式

桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立地变化。

举例：考虑装操作系统，有多种配置的计算机，同样也有多款操作系统。如何运用桥接模式呢？可以将操作系统和计算机分别抽象出来，让它们各自发展，减少它们的耦合度。当然了，两者之间有标准的接口。这样的设计，不论是对于计算机，还是操作系统都是非常有利的。

![img](http://i.imgur.com/nSlQUJm.jpg)

##### 装饰模式

装饰模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。有时我们希望给某个对象而不是整个类添加一些功能。

举例：对有一个手机，允许为其添加特性，如增加挂件、屏幕贴膜等。一个灵活的设计方式是，将手机嵌入到另一个对象中，由这个对象完成特性的添加，称此嵌入对象为修饰。这个装饰与其它所装饰的组件接口一致。故它对使用该组件的用户透明。

![img](http://i.imgur.com/nwYUFEI.jpg)

装饰模式提供了更加灵活的面向对象添加职责的方式。可以用添加和分离的方法，用装饰在运行时刻增加和删除职责。装饰模式提供了一种“即用即付”的方法来添加职责。它并不视图在一个复杂的可定制的类中支持所有可预见的特征，相反，你可以定义一个简单的类，并且用装饰类给它逐渐地添加功能。可以从简单的部件组合出复杂的功能。

#####备忘录模式

备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

举例：玩游戏时，都会保存进度，所保存的进度以文件的形式存在。下次就可以继续玩，而不是从头开始。此处的进度其实就是游戏的内部状态，文件则是游戏之外的保存状态。下次可从文件中读取保存的进度，从而恢复到原来的状态。这就是备忘录模式。

![img](http://i.imgur.com/P7uDCaw.jpg)

Memento类定义了内部的状态，而Caretake类是一个保存进度的管理者，GameRole类是游戏角色类。由上图可得GameRole的对象依赖于Memento对象，而与Caretake对象无关。

##### 中介者模式

中介者模式：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。在软件中，就是多个对象之间需要通信，如果没有中介，对象就需要知道其他对象，最坏情况下，可能需要知道所有其他的对象，而有了中介对象就方便多了，对象只需要与中介对象通信，而不用知道其他的对象。

![img](http://i.imgur.com/PZN46oA.jpg)

##### 职责链模式

职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

![img](http://i.imgur.com/HQeK3JN.jpg)

##### 观察者模式

观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。它还有两个别名，依赖（Dependents），发布-订阅（Publish-Subsrcibe）。

举例：博客订阅例子。当博主发表新文章的时候，即博主状态发生了改变，那些订阅的读者就会收到通知，然后进行相应的动作，如去看文章，或者收藏等。博主与读者之间存在一种一对多的依赖关系。

![img](http://i.imgur.com/xqpvlpB.jpg)

其中，博客类中有一个观察者链表（即订阅者），当博客的状态发生变化时，通过Notify成员函数通知所有的观察者，告诉他们博客的状态更新了。而观察者通过Update成员函数获取博客的状态信息。博客类主要完成观察者的添加、移除、通知等操作，设置和获得状态仅仅是一个默认实现。

#####状态模式

状态模式：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。它的两种使用情况：1）一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为；2）一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。

举例：以战争为例，假设一场战争需经历四个阶段：前期、中期、后期、结束。当战争处于不同的阶段，战争的行为是不一样的，即战争的行为取决于所处的阶段，而且随时间的推进是动态变化的。

![img](http://i.imgur.com/k8kUj9z.jpg)

##### 迭代器模式

迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

迭代器模式属于行为型模式。

介绍

意图：**提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。

主要解决：**不同的方式来遍历整个整合对象。

何时使用：**遍历一个聚合对象。

如何解决：**把在元素之间游走的责任交给迭代器，而不是聚合对象。

关键代码：**定义接口：hasNext, next。

应用实例：**JAVA 中的 iterator。

优点：** 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。

缺点：**由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。

使用场景：** 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。

注意事项：**迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。

实现

我们将创建一个叙述导航方法的 *Iterator* 接口和一个返回迭代器的 *Container* 接口。实现了 *Container* 接口的实体类将负责实现 *Iterator* 接口。

*IteratorPatternDemo*，我们的演示类使用实体类 *NamesRepository* 来打印 *NamesRepository* 中存储为集合的 *Names*。

![迭代器模式的 UML 图](http://www.runoob.com/wp-content/uploads/2014/08/iterator_pattern_uml_diagram.jpg)

```java
public interface Iterator {
   public boolean hasNext();
   public Object next();
}

public interface Container {
   public Iterator getIterator();
}


public class NameRepository implements Container {
   public String names[] = {"Robert" , "John" ,"Julie" , "Lora"};

   @Override
   public Iterator getIterator() {
      return new NameIterator();
   }

   private class NameIterator implements Iterator {

      int index;

      @Override
      public boolean hasNext() {
         if(index < names.length){
            return true;
         }
         return false;
      }

      @Override
      public Object next() {
         if(this.hasNext()){
            return names[index++];
         }
         return null;
      }        
   }
}

public class IteratorPatternDemo {
    
   public static void main(String[] args) {
      NameRepository namesRepository = new NameRepository();

      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){
         String name = (String)iter.next();
         System.out.println("Name : " + name);
      }     
   }
}
```

##### 各种设计模式综合

装饰者模式：包装一个对象，以提供新的行为。

状态模式：封装了基本状态行为，并使用委托在行为之间切换。

迭代器模式：在对象的集合之中游走，而不暴露集合的实现。

外观模式：简化一群类的接口。

策略模式：封装可以互换的行为，并使用委托在行为之间切换。

代理模式：包装对象，以控制对此对象的访问。

工厂方法模式：有子类决定要创建的具体类是哪一个。

适配器模式：封装对象，并提供不同的接口。

观察者模式：让对象能够在状态改变时被通知。

模板方法模式：由子类决定如何实现一个算法中的步骤。

组合模式：客户用一致的方式处理对象集合和单个对象。

单件模式：确保有且只有一个对象被创建。

抽象工厂模式：允许客户创建对象的家族，而无需指定它们的具体类。

命令模式：封装请求成为对象。

#### isp

互联网服务供应商

####计算机网络的体系结构

#### ![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//1005dc9d-9049-4b06-9524-6171e56ebd8c.png)

1. 七层协议

如图 a 所示，其中表示层和会话层用途如下：

1. 表示层：信息的语法、语义以及它们的关联，如加密解密、转换翻译、压缩解压缩；
2. 会话层：不同机器上的用户之间建立及管理会话。

2. 五层协议

1. 应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。
2. 运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
3. 网络层：为主机之间提供服务，而不是像运输层协议那样是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组来进行传输。
4. 数据链路层：网络层针对的还是主机之间，而主机之间可以有很多链路，链路层协议就是为相邻结点之间提供服务。数据链路层把网络层传来的分组封装成帧。
5. 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使物理层上的数据链路层感觉不到这些差异。

3. 数据在各层之间的传递过程

在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。

路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。

![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//ac106e7e-489a-4082-abd9-dabebe48394c.jpg)

4.tcp/ip体系结构

它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。

现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//37b74a34-251c-45f8-88a4-614ec953f7e9.png)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//37b74a34-251c-45f8-88a4-614ec953f7e9.png)

TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//93cbce0c-c37d-429c-815b-861976a46bd8.png)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//93cbce0c-c37d-429c-815b-861976a46bd8.png)

####通信方式

1. 单向通信，又称为单工通信；
2. 双向交替通信，又称为半双工通信；
3. 双向同时通信，又称为全双工通信。

## UDP 和 TCP 的特点

- 用户数据包协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。
- 传输控制协议 TCP（Transmission Control Protocol） 是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）

## TCP 首部格式

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//21a00b02-c0a6-4bcd-9af0-5ec6bb66e34c.jpg)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//21a00b02-c0a6-4bcd-9af0-5ec6bb66e34c.jpg)

- **序号** ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- **确认号** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。
- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

## TCP 的三次握手

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//086871db-5871-460f-97b7-126cd738bb0e.jpg)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//086871db-5871-460f-97b7-126cd738bb0e.jpg)

假设 A 为客户端，B 为服务器端。

1. 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
2. A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 x。
3. B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
4. A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
5. B 收到 A 的确认后，连接建立。

## TCP 的四次挥手

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//78f65456-666b-4044-b4ee-f7692dbbc0d3.jpg)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//78f65456-666b-4044-b4ee-f7692dbbc0d3.jpg)

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

1. A 发送连接释放报文段，FIN=1；
2. B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据；
3. 当 B 要不再需要连接时，发送连接释放请求报文段，FIN=1；
4. A 收到后发出确认，此时连接释放。

**TIME_WAIT**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间。这么做有两个理由：

1. 确保最后一个确认报文段能够到达。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。
2. 可能存在“已失效的连接请求报文段”，为了防止这种报文段出现在本次连接之外，需要等待一段时间。

## TCP 滑动窗口

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//223fc26e-2fd6-484c-bcb7-443cac134f15.jpg)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//223fc26e-2fd6-484c-bcb7-443cac134f15.jpg)

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 32, 34, 35}，其中 {31, 32} 按序到达，而 {34, 35} 就不是，因此只对字节 32 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

## TCP 可靠传输

TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：

​		RTTs = (1 - a)*(RTTs) + a * RTT 

P 使用的超时时间计算如下：

​		RTO = RTTs + 4*RTTd

其中RTTd为偏差，它与新的RTT和RRTs有关

其中 RTTd 为偏差，它与新的 RRT 和 RRTs 有关。

## TCP 流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。例如将窗口字段设置为 0，则发送方不能发送数据。

## TCP 拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//a69af9bb-b5ad-4896-862d-697e5ee4feb1.png)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//a69af9bb-b5ad-4896-862d-697e5ee4feb1.png)

TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护有一个叫做拥塞窗口（cwnd）的状态变量。注意拥塞窗口与发送方窗口的区别，拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

为了便于讨论，做如下假设：

1. 接收方有足够大的接收缓存，因此不会发生流量控制；
2. 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//346244ff-98c1-4f12-9a87-d0832e8c04cf.jpg)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//346244ff-98c1-4f12-9a87-d0832e8c04cf.jpg)

### 慢开始与拥塞避免

发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

### 快重传与快恢复

在接收方，要求每次接收到报文段都应该发送对已收到有序报文段的确认，例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到三个重复确认，那么可以确认下一个报文段丢失，例如收到三个 M2 ，则 M3 丢失。此时执行快重传，立即重传下一个报文段。

在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//b18d679b-c8e2-4564-88ee-7600090e46da.jpg)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//b18d679b-c8e2-4564-88ee-7600090e46da.jpg)



# 第六章 应用层*

## 域名系统 DNS

把主机名解析为 IP 地址。

被设计成分布式系统。

### 1. 层次结构

一个域名由多个层次构成，从上层到下层分别为顶级域名、二级域名、三级域名以及四级域名。所有域名可以画成一颗域名树。

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//c2117f61-1177-4768-bf33-cf4f950d911c.png)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//c2117f61-1177-4768-bf33-cf4f950d911c.png)

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//a4b162e5-db2a-4a27-b213-1fe481c5a06a.png)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//a4b162e5-db2a-4a27-b213-1fe481c5a06a.png)

域名服务器可以分为以下四类：

1. 根域名服务器：解析顶级域名；
2. 顶级域名服务器：解析二级域名；
3. 权限域名服务器：解析区内的域名；
4. 本地域名服务器：也称为默认域名服务器。可以在其中配置高速缓存。

区和域的概念不同，可以在一个域中划分多个区。图 b 在域 abc.com 中划分了两个区：abc.com 和 y.abc.com

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//fc0c6b2d-68c7-4de8-aaaa-97355a4f0472.jpg)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//fc0c6b2d-68c7-4de8-aaaa-97355a4f0472.jpg)

因此就需要两个权限域名服务器：

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//8b335d94-c1ca-42e1-ad48-bb179d28a4f1.jpg)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//8b335d94-c1ca-42e1-ad48-bb179d28a4f1.jpg)

### 2. 解析过程

主机向本地域名服务器解析的过程采用递归，而本地域名服务器向其它域名服务器解析可以使用递归和迭代两种方式。

迭代的方式下，本地域名服务器向一个域名服务器解析请求解析之后，结果返回到本地域名服务器，然后本地域名服务器继续向其它域名服务器请求解析；而递归地方式下，结果不是直接返回的，而是继续向前请求解析，最后的结果才会返回。

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//6bc61bb8-3b1c-4dc8-ac25-cef925ace0eb.jpg)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//6bc61bb8-3b1c-4dc8-ac25-cef925ace0eb.jpg)

## 文件传输协议 FTP

FTP 在运输层使用 TCP，并且需要建立两个并行的 TCP 连接：控制连接和数据连接。控制连接在整个会话期间一直保持打开，而数据连接在数据传送完毕之后就关闭。控制连接使用端口号 21，数据连接使用端口号 20。

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//58633775-8584-4a01-ad3f-eee4d9a466e1.jpg)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//58633775-8584-4a01-ad3f-eee4d9a466e1.jpg)

## 远程终端协议 TELNET

TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。

TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。

## 万维网 WWW

[HTTP](https://github.com/CyC2018/InterviewNotes/blob/master/notes/HTTP.md)

## 电子邮件协议

一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件发送协议和读取协议。其中发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//de1e46d2-748f-4da3-a29e-7de7bc840366.jpg)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//de1e46d2-748f-4da3-a29e-7de7bc840366.jpg)

### POP3

POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。

### IMAP

IMAP 协议中客户端和服务器上的邮件保持同步，如果不去手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。IMAP 协议也支持创建自定义的文件夹。

### SMTP

SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主题的结构，定义了非 ASCII 码的编码规则。

[![img](https://github.com/CyC2018/InterviewNotes/raw/master/pics//ed5522bb-3a60-481c-8654-43e7195a48fe.png)](https://github.com/CyC2018/InterviewNotes/blob/master/pics//ed5522bb-3a60-481c-8654-43e7195a48fe.png)

## 动态主机配置协议 DHCP

DHCP 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。

DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、默认路由器 IP 地址、域名服务器的 IP 地址。

工作方式如下：需要 IP 地址的主机广播发送 DHCP 发现报文（将目的地址置为全 1，即 255.255.255.255:67，源地址设置为全 0，即 0.0.0.0:68），DHCP 服务器收到发现报文之后，则在 IP 地址池中取一个地址，发送 DHCP 提供报文给该主机。

## 点对点传输 P2P

把某个文件分发的所有对等集合称为一个洪流。文件的数据单元称为文件块，它的大小是固定的。一个新的对等方加入某个洪流，一开始并没有文件块，但是能够从其它对等方中逐渐地下载到一些文件块，与此同时，它也为别的对等方上传一些文件块。

每个洪流都有一个基础设施，称为追踪器。当一个对等方加入洪流时，必须向追踪器登记，并周期性地通知追踪器它仍在洪流中。可以在任何时间加入和退出某个洪流。

一个新的对等方加入洪流时，追踪器会随机从洪流中选择若干个对等方，并让新对等方与这些对等方建立连接，把这些对等方称为相邻对等方。接收和发送文件块都是在相邻对等方中进行。

当一个对等方需要很多文件块时，通过使用最稀有优先的策略来取得文件块，也就是一个文件块在相邻对等方中副本最少，那么就优先请求这个文件块。

当很多对等方向同一个对等方请求文件块时，该对等方优先选择以最高速率向其发送文件块的对等方。

P2P 是一个分布式系统，任何时候都有对等方加入或者退出。使用分布式散列表 DHT，可以查找洪流中的资源和 IP 地址映射。

## Web 页面请求过程

1. 向 DNS 服务器发送 DNS 查询报文来解析域名。
2. 开始进行 HTTP 会话，需要先建立 TCP 连接。
3. 在运输层的传输过程中，HTTP 报文被封装进 TCP 中。HTTP 请求报文使用端口号 80，因为服务器监听的是 80 端口。连接建立之后，服务器会随机分配一个端口号给特定的客户端，之后的 TCP 传输都是用这个分配的端口号。
4. 在网络层的传输过程中，TCP 报文段会被封装进 IP 分组中，IP 分组经过路由选择，最后到达目的地。
5. 在链路层，IP 分组会被封装进 MAC 帧中，IP 地址解析成 MAC 地址需要使用 ARP。
6. 客户端发送 HTTP 请求报文，请求获取页面。
7. 服务器发送 HTTP 相应报文，客户端从而获取该页面。
8. 浏览器得到页面内容之后，解析并渲染，向用户展示页面。

## 常用端口

| 应用层协议 | 端口号                   | 运输层协议 |
| ---------- | ------------------------ | ---------- |
| DNS        | 53                       | UDP        |
| FTP        | 控制连接 21，数据连接 20 | TCP        |
| TELNET     | 23                       | TCP        |
| DHCP       | 67 68                    | UDP        |
| HTTP       | 80                       | TCP        |
| SMTP       | 25                       | TCP        |
| POP3       | 110                      | TCP        |
| IMAP       | 143                      | TCP        |

cn：顶级域名,代表某个国家、地区或大型机构。
com：网络名,也叫二级域名， 代表部门系统或隶属一级区域的下级机构。
sina：三级域名,即组织机构名,是本系统、单位或院所的软硬件平台的名称。



